<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Jingwen Blog</title>
    <description>关于程序与设计、黑客与画家，Web &amp; Mobile Lover，Software Engineer，UX Designer | 这里是 景闻 的个人博客，与你一起发现更大的世界。</description>
    <link>https://huangxuan.me/</link>
    <atom:link href="https://huangxuan.me/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 07 Apr 2020 17:32:52 +0800</pubDate>
    <lastBuildDate>Tue, 07 Apr 2020 17:32:52 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>Perl子程序</title>
        <description>&lt;h2 id=&quot;perl子程序&quot;&gt;Perl子程序&lt;/h2&gt;
&lt;p&gt;Perl也可以让你创建子程序(subroutine)，也就是用户定义的函数，它可以让程序员重复利用已有的代码，也能让代码更加美观和可读性。子程序的名称也属于Perl标识符的范畴(即由字母，数字和下划线组成，但不能以数字开头)，有时候视情况会以”&amp;amp;”开头。&lt;/p&gt;

&lt;h3 id=&quot;子程序定义&quot;&gt;子程序定义&lt;/h3&gt;
&lt;p&gt;定义子程序需要用关键字sub，子程序名，以及用花括号封闭起来的代码块，这部分代码是子程序的主体。例如&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    sub marine{
        $n += 1 ;
        print &quot;Hello,sailor number $n|\n&quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;子程序可以被定义在程序中的任何位置，有C语言程序背景的程序员喜欢把子程序定义在文件的开头。子程序的定义是全局的，假如你定义了两个重名的子程序，那么后面的子程序会覆盖掉前面的那个。&lt;/p&gt;

&lt;h3 id=&quot;调用子程序&quot;&gt;调用子程序&lt;/h3&gt;
&lt;p&gt;你可以在任意表达式中使用子程序名，前面加上&amp;amp;来调用它。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    &amp;amp;marine
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;返回值&quot;&gt;返回值&lt;/h3&gt;
&lt;p&gt;往往我们调用子程序的时候，都是希望能获得子程序返回的结果，来做进一步处理，在Perl中所有的子程序都有返回值。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    #!/usr/bin/perl
    use strict;
    use  warnings;
    my $fred = 3;
    my $barney = 4;
    sub sum_of_fred_and_barney{
        print &quot;Hey,you&quot;;
        $fred + $barney;
    }
    my $wilia = &amp;amp;sum_of_fred_and_barney;
    print &quot;length = $wilia\n&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;参数&quot;&gt;参数&lt;/h3&gt;
&lt;p&gt;Perl子程序可以有参数(argument)。要传递参数列表到子程序里，只要在子程序调用的后面加上被括号圈引的列表表达式就行了。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    $n = &amp;amp;max(10,15)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会调用子程序名为max的子程序，并且将参数10，15会被传入子程序，让子程序随意用。该子程序的第一个参数存储于$&lt;em&gt;[0],第二个参数存储于$&lt;/em&gt;[1],依次类推&lt;/p&gt;

&lt;h3 id=&quot;私有变量&quot;&gt;私有变量&lt;/h3&gt;
&lt;p&gt;默认的情况下，Perl里面所有的变量都是全局变量，也就是说，在程序里的任何地方都可以访问它们，但是你可以随时借助my操作符来创建私有变量。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常情况下，在代码的语句块内容，是按照代码的顺序执行，也就是函数中的第一个语句先执行，接着是第二个语句，依次类推。编程语言提供了更为复杂的执行路径的多种控制语句，循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的流程图
&lt;img src=&quot;https://jingwen-blog.oss-cn-beijing.aliyuncs.com/loop.png&quot; alt=&quot;&amp;quot;循环语句流程&amp;quot;&quot; /&gt;
&lt;strong&gt;注意，数字 0, 字符串 ‘0’ 、 “” , 空 list () , 和 undef 为 false ，其他值均为 true。 true 前面使用 ! 或 not则返回 false 。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;while循环&quot;&gt;while循环&lt;/h3&gt;
&lt;p&gt;while语句在给定条件为true时，重复执行语句或语句组。循环主题执行之前会测试条件。
语法格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;while(condition)
{
   statement(s);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里，statement(s)可以是一个单独的语句，也可以是几个语句组成的语句块，或者函数。condition可以是任意的表达式，当为任意非零值时都为true，条件为true时，执行循环体。&lt;/p&gt;

&lt;h3 id=&quot;until循环&quot;&gt;until循环&lt;/h3&gt;
&lt;p&gt;until 语句在给定条件为 false 时，重复执行语句或语句组。
语法格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;until(condition)
{
   statement(s);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个就刚好跟while循环相反了，不知道这个设计真正的作用是什么&lt;/p&gt;

&lt;h3 id=&quot;for循环&quot;&gt;for循环&lt;/h3&gt;
&lt;p&gt;Perl的for循环用于多次执行一个语句系列，让代码更简洁
语法格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    for(init;condition;increment){
        statements(s);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for的流程图为
&lt;img src=&quot;https://jingwen-blog.oss-cn-beijing.aliyuncs.com/forloop.png&quot; alt=&quot;&amp;quot;for的流程图&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;for的流程控制语句解析&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;init首先会被执行，且只会出现一次。这一语句允许您声明并且初始化任何循环控制变量，当然这里也可以不需要任何语句，只是一个分号(;)即可&lt;/li&gt;
  &lt;li&gt;condition，接下来会判断condition的条件，如果为true，会继续执行循环主体。如果为false，那么就会执行for循环的下一条语句也就是increment语句&lt;/li&gt;
  &lt;li&gt;一旦condition的条件为true时，就会执行循环体statements(s)，执行结束之后，才会执行increment语句&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    #!/usr/bin/perl
    for( $a = 0; $a &amp;lt; 10; $a = $a + 1 ){
        print &quot;a 的值为: $a\n&quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;foreach循环&quot;&gt;foreach循环&lt;/h3&gt;
&lt;p&gt;用于迭代一个列表或集合或数组变量的值
语法格式为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    foreach var (list) {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    #!/usr/bin/perl
    @list = (2, 12, 36, 42, 51);
    # 执行foreach 循环
    foreach $a (@list){
        print &quot;a 的值为: $a\n&quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;do-while循环&quot;&gt;do while循环&lt;/h3&gt;
&lt;p&gt;不像 for 和 while 循环，它们是在循环头部测试循环条件。在 Perl 语言中，do…while 循环是在循环的尾部检查它的条件。&lt;/p&gt;

&lt;p&gt;do…while 循环与 while 循环类似，但是 do…while 循环会确保至少执行一次循环。&lt;/p&gt;

&lt;p&gt;语法格式为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    do
    {
       statement(s);
    }while( condition );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;*条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;代码案例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    #!/usr/bin/perl
    $a = 10;
    # 执行 do...while 循环
    do{
       printf &quot;a 的值为: $a\n&quot;;
       $a = $a + 1;
    }while( $a &amp;lt; 15 );
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;perl控制语句&quot;&gt;Perl控制语句&lt;/h2&gt;
&lt;p&gt;循环控制语句改变了代码的执行顺序，通过控制语句你可以实现代码的跳转&lt;/p&gt;

&lt;h3 id=&quot;next语句&quot;&gt;next语句&lt;/h3&gt;
&lt;p&gt;Perl next 语句用于停止执行从next语句的下一语句开始到循环体结束标识符之间的语句，转去执行continue语句块，然后再返回到循环体的起始处开始执行下一次循环。&lt;/p&gt;

&lt;p&gt;语法为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    next [ LABEL ]; ##其中 LABEL 是可选的，如果没有指定 LABEL，next 语句将返回到循环体的起始处开始执行下一次循环。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;last语句&quot;&gt;last语句&lt;/h3&gt;
&lt;p&gt;Perl last 语句用于退出循环语句块，从而结束循环，last语句之后的语句不再执行，continue语句块也不再执行。&lt;/p&gt;

&lt;p&gt;语法为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    last [ LABEL ]; ##其中 LABEL 是可选的
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;continue语句&quot;&gt;continue语句&lt;/h3&gt;
&lt;p&gt;Perl continue 块通常在条件语句再次判断前执行。continue 语句可用在 while 和 foreach 循环中。&lt;/p&gt;

&lt;p&gt;while 循环中 continue 语句语法格式如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    while(condition){
        statement(s);
    }continue{
        statement(s);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;foreach 循环中 continue 语句语法格式如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    foreach $a (@listA){
        statement(s);
    }continue{
        statement(s);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;redo语句&quot;&gt;redo语句&lt;/h3&gt;
&lt;p&gt;Perl redo 语句直接转到循环体的第一行开始重复执行本次循环，redo语句之后的语句不再执行，continue语句块也不再执行。continue 语句可用在 while 和 foreach 循环中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jingwen-blog.oss-cn-beijing.aliyuncs.com/redo.jpg&quot; alt=&quot;&amp;quot;redo&amp;quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 18 Nov 2019 20:40:00 +0800</pubDate>
        <link>https://huangxuan.me/2019/11/18/Perl%E5%AD%90%E7%A8%8B%E5%BA%8F/</link>
        <guid isPermaLink="true">https://huangxuan.me/2019/11/18/Perl%E5%AD%90%E7%A8%8B%E5%BA%8F/</guid>
        
        <category>Perl</category>
        
        <category>programming</category>
        
        
      </item>
    
      <item>
        <title>kafka</title>
        <description>&lt;h2 id=&quot;kafka入门&quot;&gt;kafka入门&lt;/h2&gt;
&lt;p&gt;kafka是由Linkedin公司开发的一个分布式(distributed)，多分区(partition)，多副本(replica)基于zookeeper协调的分布式消息系统。Linkedin在2010年贡献给了Apache基金会并成为顶级开源项目。如今Apache官方把它称作是A distributed streaming platform。主要用来构建实时数据流和流应用。&lt;/p&gt;
&lt;h2 id=&quot;特点&quot;&gt;特点&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;发布&amp;amp;订阅
    &lt;ul&gt;
      &lt;li&gt;像一个消息系统一样的进行读取和写入流式数据&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;处理
    &lt;ul&gt;
      &lt;li&gt;编写可扩展的流处理应用处理实时处理的中的事件&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;存储
    &lt;ul&gt;
      &lt;li&gt;在一个分布式，多副本，容错性的集群上非常安全的存储流式数据&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;设计原理&quot;&gt;设计原理&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;* NIO
* Zero Copy
* 磁盘顺序读写
* Queue数据结构
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;quickstart&quot;&gt;Quickstart&lt;/h2&gt;

&lt;h3 id=&quot;step-1-download-the-code&quot;&gt;Step 1: Download the code&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.apache.org/dyn/closer.cgi?path=/kafka/2.3.0/kafka_2.12-2.3.0.tgz&quot;&gt;Download&lt;/a&gt; the 2.3.0 release and un-tar it.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;tar -xzf kafka_2.12-2.3.0.tgz&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cd kafka_2.12-2.3.0&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;step-2-start-the-server&quot;&gt;Step 2: Start the server&lt;/h3&gt;
&lt;p&gt;kafka使用zookeeper来进行协调管理，因此首先需要启动zookeeper服务，启动单个节点的zookeeper instance&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bin/zookeeper-server-start.sh config/zookeeper.properties&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;再启动kafka server&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bin/kafka-server-start.sh config/server.properties&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;step-3-create-a-topic&quot;&gt;Step 3: Create a topic&lt;/h3&gt;
&lt;p&gt;创建一个名字为test的topic，包含一个分区和一个副本&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 1 --partitions 1 --topic test&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后可以查看集群上的topic列表&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bin/kafka-topics.sh --list --bootstrap-server localhost:9092&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;step-4-send-some-messages&quot;&gt;Step 4: Send some messages&lt;/h3&gt;
&lt;p&gt;kafka通过客户端的命令行可以将一个文件的内容或者标准的输入内容发送到kafka集群，默认的每一行都会作为一个单独的消息&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bin/kafka-console-producer.sh --broker-list localhost:9092 --topic test&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;step-5-start-a-consumer&quot;&gt;Step 5: Start a consumer&lt;/h3&gt;
&lt;p&gt;kafka也能通过一个消费的命令行从集群消费消息到标准输出&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bin/kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;step-6-setting-up-a-multi-broker-cluster&quot;&gt;Step 6: Setting up a multi-broker cluster&lt;/h3&gt;
&lt;p&gt;扩展我们的集群节点(broker)到三个节点&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cp config/server.properties config/server-1.properties&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cp config/server.properties config/server-2.properties&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;编辑三个broker配置的文件&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;1.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;broker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;listeners&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PLAINTEXT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9093&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kafka&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
 
&lt;span class=&quot;n&quot;&gt;config&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;server&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;2.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;properties&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;broker&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;listeners&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PLAINTEXT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;9094&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dirs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kafka&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;logs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;broker.id属性是集群上每一个broker节点上的唯一值和永久的名称&lt;/p&gt;

&lt;p&gt;同样的也需要扩展到三个zookeeper节点&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bin/kafka-server-start.sh config/server-1.properties &amp;amp;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bin/kafka-server-start.sh config/server-2.properties &amp;amp;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;创建一个新的topic有三个副本&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bin/kafka-topics.sh --create --bootstrap-server localhost:9092 --replication-factor 3 --partitions 1 --topic my-replicated-topic&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;采用describe topics命令查看每一个broker上的运行情况&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bin/kafka-topics.sh --describe --bootstrap-server localhost:9092 --topic my-replicated-topic&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    &lt;span class=&quot;n&quot;&gt;Topic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;my&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;replicated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;topic&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;PartitionCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;ReplicationFactor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Configs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Topic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;replicated&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;topic&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;Partition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;Leader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;   &lt;span class=&quot;n&quot;&gt;Replicas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Isr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Tue, 12 Nov 2019 20:00:00 +0800</pubDate>
        <link>https://huangxuan.me/2019/11/12/kafka/</link>
        <guid isPermaLink="true">https://huangxuan.me/2019/11/12/kafka/</guid>
        
        <category>kafka</category>
        
        <category>bigdata</category>
        
        
      </item>
    
      <item>
        <title>Perl循环和控制语句</title>
        <description>&lt;h2 id=&quot;perl循环&quot;&gt;Perl循环&lt;/h2&gt;
&lt;p&gt;通常情况下，在代码的语句块内容，是按照代码的顺序执行，也就是函数中的第一个语句先执行，接着是第二个语句，依次类推。编程语言提供了更为复杂的执行路径的多种控制语句，循环语句允许我们多次执行一个语句或语句组，下面是大多数编程语言中循环语句的流程图
&lt;img src=&quot;https://jingwen-blog.oss-cn-beijing.aliyuncs.com/loop.png&quot; alt=&quot;&amp;quot;循环语句流程&amp;quot;&quot; /&gt;
&lt;strong&gt;注意，数字 0, 字符串 ‘0’ 、 “” , 空 list () , 和 undef 为 false ，其他值均为 true。 true 前面使用 ! 或 not则返回 false 。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;while循环&quot;&gt;while循环&lt;/h3&gt;
&lt;p&gt;while语句在给定条件为true时，重复执行语句或语句组。循环主题执行之前会测试条件。
语法格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;while(condition)
{
   statement(s);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这里，statement(s)可以是一个单独的语句，也可以是几个语句组成的语句块，或者函数。condition可以是任意的表达式，当为任意非零值时都为true，条件为true时，执行循环体。&lt;/p&gt;

&lt;h3 id=&quot;until循环&quot;&gt;until循环&lt;/h3&gt;
&lt;p&gt;until 语句在给定条件为 false 时，重复执行语句或语句组。
语法格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;until(condition)
{
   statement(s);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个就刚好跟while循环相反了，不知道这个设计真正的作用是什么&lt;/p&gt;

&lt;h3 id=&quot;for循环&quot;&gt;for循环&lt;/h3&gt;
&lt;p&gt;Perl的for循环用于多次执行一个语句系列，让代码更简洁
语法格式如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    for(init;condition;increment){
        statements(s);
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for的流程图为
&lt;img src=&quot;https://jingwen-blog.oss-cn-beijing.aliyuncs.com/forloop.png&quot; alt=&quot;&amp;quot;for的流程图&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;for的流程控制语句解析&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;init首先会被执行，且只会出现一次。这一语句允许您声明并且初始化任何循环控制变量，当然这里也可以不需要任何语句，只是一个分号(;)即可&lt;/li&gt;
  &lt;li&gt;condition，接下来会判断condition的条件，如果为true，会继续执行循环主体。如果为false，那么就会执行for循环的下一条语句也就是increment语句&lt;/li&gt;
  &lt;li&gt;一旦condition的条件为true时，就会执行循环体statements(s)，执行结束之后，才会执行increment语句&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    #!/usr/bin/perl
    for( $a = 0; $a &amp;lt; 10; $a = $a + 1 ){
        print &quot;a 的值为: $a\n&quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;foreach循环&quot;&gt;foreach循环&lt;/h3&gt;
&lt;p&gt;用于迭代一个列表或集合或数组变量的值
语法格式为&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    foreach var (list) {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实例为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    #!/usr/bin/perl
    @list = (2, 12, 36, 42, 51);
    # 执行foreach 循环
    foreach $a (@list){
        print &quot;a 的值为: $a\n&quot;;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;do-while循环&quot;&gt;do while循环&lt;/h3&gt;
&lt;p&gt;不像 for 和 while 循环，它们是在循环头部测试循环条件。在 Perl 语言中，do…while 循环是在循环的尾部检查它的条件。&lt;/p&gt;

&lt;p&gt;do…while 循环与 while 循环类似，但是 do…while 循环会确保至少执行一次循环。&lt;/p&gt;

&lt;p&gt;语法格式为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    do
    {
       statement(s);
    }while( condition );
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;*条件表达式出现在循环的尾部，所以循环中的 statement(s) 会在条件被测试之前至少执行一次。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;代码案例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    #!/usr/bin/perl
    $a = 10;
    # 执行 do...while 循环
    do{
       printf &quot;a 的值为: $a\n&quot;;
       $a = $a + 1;
    }while( $a &amp;lt; 15 );
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;perl控制语句&quot;&gt;Perl控制语句&lt;/h2&gt;
&lt;p&gt;循环控制语句改变了代码的执行顺序，通过控制语句你可以实现代码的跳转&lt;/p&gt;

&lt;h3 id=&quot;next语句&quot;&gt;next语句&lt;/h3&gt;
&lt;p&gt;Perl next 语句用于停止执行从next语句的下一语句开始到循环体结束标识符之间的语句，转去执行continue语句块，然后再返回到循环体的起始处开始执行下一次循环。&lt;/p&gt;

&lt;p&gt;语法为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    next [ LABEL ]; ##其中 LABEL 是可选的，如果没有指定 LABEL，next 语句将返回到循环体的起始处开始执行下一次循环。
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;last语句&quot;&gt;last语句&lt;/h3&gt;
&lt;p&gt;Perl last 语句用于退出循环语句块，从而结束循环，last语句之后的语句不再执行，continue语句块也不再执行。&lt;/p&gt;

&lt;p&gt;语法为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    last [ LABEL ]; ##其中 LABEL 是可选的
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;continue语句&quot;&gt;continue语句&lt;/h3&gt;
&lt;p&gt;Perl continue 块通常在条件语句再次判断前执行。continue 语句可用在 while 和 foreach 循环中。&lt;/p&gt;

&lt;p&gt;while 循环中 continue 语句语法格式如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    while(condition){
        statement(s);
    }continue{
        statement(s);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;foreach 循环中 continue 语句语法格式如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Perl&quot;&gt;    foreach $a (@listA){
        statement(s);
    }continue{
        statement(s);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;redo语句&quot;&gt;redo语句&lt;/h3&gt;
&lt;p&gt;Perl redo 语句直接转到循环体的第一行开始重复执行本次循环，redo语句之后的语句不再执行，continue语句块也不再执行。continue 语句可用在 while 和 foreach 循环中。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://jingwen-blog.oss-cn-beijing.aliyuncs.com/redo.jpg&quot; alt=&quot;&amp;quot;redo&amp;quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sat, 09 Nov 2019 20:00:00 +0800</pubDate>
        <link>https://huangxuan.me/2019/11/09/perl%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</link>
        <guid isPermaLink="true">https://huangxuan.me/2019/11/09/perl%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</guid>
        
        <category>Perl</category>
        
        <category>programming</category>
        
        
      </item>
    
      <item>
        <title>Perl列表与数组</title>
        <description>&lt;h2 id=&quot;列表和数组&quot;&gt;列表和数组&lt;/h2&gt;
&lt;p&gt;同其它语言一样，列表(list)和数组(array)中的每个元数都有相应的整数作为索引，次数字从0开始递增，每次加1，所以数组和列表的头一个元数总是第0个元数。&lt;/p&gt;
&lt;h2 id=&quot;数组&quot;&gt;数组&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;数组初始化
  $rocks[0] = “bedrock” ; 
  $rocks[1] = ‘slate’ ; &lt;br /&gt;
  $rocks[2] = ‘lava’  ;  &lt;br /&gt;
  $rocks[3] = ‘crushed rock’ ;&lt;br /&gt;
  $rocks[99] = ‘shcist’ ;   #现有95个undef元素&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;数组的长度是没有限制的，对索引值超过数组尾端的元数进行赋值，数组将会自动根据需要扩大，在扩展过程中，需要创建增补的元数，那么他们的默认值为undef。&lt;/li&gt;
      &lt;li&gt;数组最后一个元数的索引值 $end = $#rocks,&lt;strong&gt;用法比较常见&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;数组的长度 $number_of_rocks = $end +1&lt;/li&gt;
      &lt;li&gt;最后的元数的值 $rocks[$#rocks]&lt;/li&gt;
      &lt;li&gt;负数索引值
        &lt;ul&gt;
          &lt;li&gt;最后一个元数，索引值为-1&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;列表&quot;&gt;列表&lt;/h2&gt;
&lt;p&gt;由圆括号内用逗号隔开的一串数据表示，而这些数据就称为列表元数。
(1,2,3)  #包含1，2，3这三个数字的列表
(1,2,3,) #包含1，2，3这三个数字的列表,末尾的逗号会被忽略
(1..100) #100个整数构成的列表，&lt;strong&gt;…&lt;/strong&gt;范围操作符，该操作符会从左边的数字计数到右边，每次加1，以产生一串联的数字
(0..$#rocks)，列表rocks中所有的索引&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;赋值
  @(at),全部的，所有的
  @rocks = ();  #空列表
  @giant = 1..1e5  #包含100 000个元数的列表
  @stuff = (@giant,undef，@giant) #包含200 001个元数的列表&lt;/li&gt;
  &lt;li&gt;qw
qw表示”quoted word”加上引号的单词，就是比如 @rckis = qw(fred barney betty wilma dino) 会变成@rckis = (‘fred’,’barney’,’betty’,’wilma’,’dino’)&lt;/li&gt;
  &lt;li&gt;pop和push
  在Perl中通常把数组当做堆栈(stack)来使用，数组中最右侧的便是最后一个元数，也就是拥有最大索引值的那个元数。
    &lt;ul&gt;
      &lt;li&gt;pop负责取出数组中最后一个元数并将其作为返回值返回
        &lt;ul&gt;
          &lt;li&gt;@array = 5..9 ;&lt;/li&gt;
          &lt;li&gt;$fred = pop(@array);  #fred变成9，@array现在是(5，6，7，8)&lt;/li&gt;
          &lt;li&gt;$barney = pop(@array);#barney变成8，@array现在是(5,6,7)&lt;/li&gt;
          &lt;li&gt;pop @array ;  #@array现在是(5,6),7被无情的抛弃掉了&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;push负责添加一个元数到数组的末端
        &lt;ul&gt;
          &lt;li&gt;push(@array,0); #@array现在是(5,6,0)&lt;/li&gt;
          &lt;li&gt;push @array,8 ; #@array现在是(5,6,8,0)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;push和pop操作都可以去掉括号的&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;shift和unshift
    &lt;ul&gt;
      &lt;li&gt;push和pop的操作是对数组的尾端，similarity，shift(从数组头部取一个元数出来)和unshift(从头部增加一个元素和)是数组开头进行相应的处理，&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 07 Nov 2019 00:00:00 +0800</pubDate>
        <link>https://huangxuan.me/2019/11/07/perl%E5%88%97%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84/</link>
        <guid isPermaLink="true">https://huangxuan.me/2019/11/07/perl%E5%88%97%E8%A1%A8%E4%B8%8E%E6%95%B0%E7%BB%84/</guid>
        
        
      </item>
    
      <item>
        <title>Perl标量数据</title>
        <description>&lt;h2 id=&quot;标量&quot;&gt;标量&lt;/h2&gt;
&lt;p&gt;标量是Perl里面最简单的一种数据类型，对大部分的标量来说，它要么是数据比如(100或是3.75e20)，要么是由字符串组成的序列。对于Perl来说，字符串和数据在大多数情况下是可以内部转换的，你可以用操作符对标量进行操作，产生的结果通常也是一个标量。标量可以存储在标量的变量里面。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;数字
    &lt;ul&gt;
      &lt;li&gt;整数直接量
        &lt;ul&gt;
          &lt;li&gt;0,2001,-40，61323228440128223 这些都是整数，但是你会发现Perl有一个很牛逼的地方就是可以用下划线61_323_228_440_128_223和61323228440128223表示同一个数字，只是写法不同。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;浮点数直接量
        &lt;ul&gt;
          &lt;li&gt;小数点与前置的正负号都是可选的，数据后面也可以加上用”e”表示的10的此房标识符(即指数表示法)。整数和浮点数在Perl中都是双精度类型来存储的&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;非十进制整数直接量
        &lt;ul&gt;
          &lt;li&gt;Perl也允许使用十进制(decimal)以外的其他进制来表示数字。八进制(octal)直接量是以0开头，十六进制(hexadecimal)直接量以0x开头，而二进制(binary)直接量以0b开头。0377表示八进制的377，等于十进制的255；oxff表示十六进制的FF(ff)，也等于十进制的255；0b1111111表示二进制的11111111，也等于十进制的255，虽然三个数据不相同，但是对于Perl而言都是同一个数据。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;数字操作符
    &lt;ul&gt;
      &lt;li&gt;数据运算操作符相比较于其他语言一样，最基本的四则运算 加减乘除
        &lt;ul&gt;
          &lt;li&gt;2+3 ，5.1-2.4，3*12，14/2，10%3(取模)&lt;/li&gt;
          &lt;li&gt;2**3(乘幂操作)，2的3次方&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;字符串 字符串通常是由可输出的字母，数字及标点符号组成，其范围介于ASCII编码的32到126之间
    &lt;ul&gt;
      &lt;li&gt;单引号字符串直接量
        &lt;ul&gt;
          &lt;li&gt;单引号内的字符串直接量(single-quoted string literal)指的是一对单引号(‘‘)圈起来的一串字符，单引号内所有的字符都代表它们自己(包括换行符)。要表示反斜线字符本身，需要在这个反斜线字符前再加一个反斜线字符表示转义；要表示单引号本身时，同样在单引号前加一个反斜线字符表示转义。&lt;strong&gt;单引号内的\n并不是换行符，表示反斜线和n，只有在反斜线后面接单引号或者反斜线，才表示转义&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;双引号字符串直接量
        &lt;ul&gt;
          &lt;li&gt;双引号内的字符串直接量(double-quoted string literal)指的是一对双引号(““)圈起来的一串字符，不过双引号中的反斜线更为强大，可以转义许多控制字符，或是用八进制或十六进制写法来表示任何字符。&lt;strong&gt;对Perl来说单引号和双引号表示的字符串是相同的，一般来说要想通过反斜线来转义表示换行符\n这样的特殊字符的话，就用该双引号书写直接量&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;双引号反斜线转义
   &lt;img src=&quot;https://jingwen-blog.oss-cn-beijing.aliyuncs.com/%E5%8F%8D%E6%96%9C%E7%BA%BF%E8%BD%AC%E4%B9%89.png&quot; alt=&quot;&amp;quot;双引号反斜线转义&amp;quot;&quot; /&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;标量变量&quot;&gt;标量变量&lt;/h2&gt;
&lt;p&gt;所谓变量(variable)，就是存储一个值或多个值的容器的名称，而标量变量就是单单存储一个值的变量。标量变量存储的是单个标量值。标量变量的名称以美元符号开头，这个符号也成为魔符(sigil)，然后标识符由一个字符或下划线开头，后接多个字母，数据或下划线。&lt;strong&gt;标识符是区分大小写。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;注意
    &lt;ul&gt;
      &lt;li&gt;Perl程序里面的大部分变量名称都习惯使用全小写，而使用全大写的变量一般都表示特殊的意义的变量&lt;/li&gt;
      &lt;li&gt;如果变量名称不止一个单词，则使用下划线分开 $underscores_are_cool,也可以使用驼峰式风格&lt;/li&gt;
      &lt;li&gt;也可以使用驼峰式风格例如$giveMeInitialCaps&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;标量赋值&quot;&gt;标量赋值&lt;/h2&gt;
&lt;p&gt;对标量最常见的操作就是赋值(assignment)，也就是将某个值存进变量中，Perl的赋值操作为等号。$fred = 17; 还可以使用双目赋值赋值操作&lt;/p&gt;

&lt;h2 id=&quot;比较操作符&quot;&gt;比较操作符&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jingwen-blog.oss-cn-beijing.aliyuncs.com/Perl%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C%E7%AC%A6.png&quot; alt=&quot;&amp;quot;比较操作符&amp;quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;布尔值&quot;&gt;布尔值&lt;/h2&gt;
&lt;p&gt;Perl并没有专用的”布尔(Boolean)”数据类型，它是靠一些简单的规则来判断的&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果是数字，0为假；其他所有的数据都是真&lt;/li&gt;
  &lt;li&gt;如果是字符串，空字符串(‘‘)为假，其他所有字符串都为真&lt;/li&gt;
  &lt;li&gt;如果既不是数字也不是字符串，那就先转换成数据或者字符串&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;用户输入&quot;&gt;用户输入&lt;/h2&gt;
&lt;p&gt;就是Perl程序从键盘读取用户的标准输入的值，最简单的方式就是使用”行输入”操作符&lt;strong&gt;STDIN&lt;/strong&gt; 
Perl代码写法就是 $line = &amp;lt;STDIN&amp;gt;;&lt;/p&gt;

</description>
        <pubDate>Tue, 05 Nov 2019 00:00:00 +0800</pubDate>
        <link>https://huangxuan.me/2019/11/05/perl%E6%A0%87%E9%87%8F%E6%95%B0%E6%8D%AE/</link>
        <guid isPermaLink="true">https://huangxuan.me/2019/11/05/perl%E6%A0%87%E9%87%8F%E6%95%B0%E6%8D%AE/</guid>
        
        
      </item>
    
      <item>
        <title>Perl命令</title>
        <description>&lt;h2 id=&quot;usrbinperl&quot;&gt;#!/usr/bin/perl&lt;/h2&gt;
&lt;p&gt;在Unix系统中，如果文件开头的最前面是两个字符#!,那么后面跟着的就是用来执行这个文件的程序路径，在Perl的脚本中就是/usr/bin/perl，正式由于必须强调这样的命令，导致perl脚本程序可移植性变得比较差，因为存在每台机器上perl解释器的路径不一样。不过大多数机器下的perl解释器的路径一般在/usr/bin/perl或者/usr/local/bin/perl下。如果不确定的话就写成&lt;/p&gt;
&lt;div class=&quot;language-perl highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    &lt;span class=&quot;c1&quot;&gt;#!/usr/bin/envperl&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&quot;use和require&quot;&gt;use和require&lt;/h2&gt;
&lt;p&gt;我们经常开发Perl脚本代码的时候，文件最顶部经常会发现use xxx或者 require “xxx.pm”，这表示该文件需要加载和引用Perl的xxx module
use语句则是告诉Perl在@INC路径寻找xxx.pm并包含到解析的源文件拷贝中。use语句是使用类必须的。
use和require的区别 
&lt;img src=&quot;https://jingwen-blog.oss-cn-beijing.aliyuncs.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-11-05%20%E4%B8%8B%E5%8D%887.13.43.png&quot; alt=&quot;use和require的区别&quot; title=&quot;use和require的区别&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;use-strict&quot;&gt;use strict&lt;/h2&gt;
&lt;p&gt;程序员编写代码，运行时候排查错误是是很常见的事情，尤其是写Perl这样的脚本语言，在文件的开头加上&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    &lt;span class=&quot;n&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strict&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;strict这个关键字的作用是强迫程序开发者使用比较严谨的Perl写法，避开一些比较容易出错的编写方式，让代码在运行出错的时候，更高效的去排查问题。脚本中加上了strict之后，在整个代码中就会有很多的限制就是在定义任何的变量之前一定需要加上关键字&lt;strong&gt;my&lt;/strong&gt;。尤其是当你的程序会有很多行的时候&lt;/p&gt;
&lt;h2 id=&quot;use-warnings&quot;&gt;use warnings&lt;/h2&gt;
&lt;p&gt;warnings就意味着Perl程序开启了所有的警告信息，让程序员更容易发觉代码可能会出问题的地方。一般都是跟着strict一起使用&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    &lt;span class=&quot;n&quot;&gt;use&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;warnings&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Sun, 03 Nov 2019 20:00:00 +0800</pubDate>
        <link>https://huangxuan.me/2019/11/03/perl%E5%91%BD%E4%BB%A4/</link>
        <guid isPermaLink="true">https://huangxuan.me/2019/11/03/perl%E5%91%BD%E4%BB%A4/</guid>
        
        <category>Perl</category>
        
        <category>programming</category>
        
        
      </item>
    
      <item>
        <title>PERL简介</title>
        <description>&lt;h2 id=&quot;perl简介&quot;&gt;PERL简介&lt;/h2&gt;
&lt;p&gt;PERL是Practical Extraction and Report Language的简写，即实用摘录与报表语言，由Larry Wall在1987年发明的一种编程语言，主要用来进行文本处理。对于Perl来说，最重要的就是正则表达式以及强大的第三方库CPAN了。&lt;/p&gt;
&lt;h2 id=&quot;perl之父&quot;&gt;PERL之父&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jingwen-blog.oss-cn-beijing.aliyuncs.com/Larry%20Wall.jpg&quot; alt=&quot;Larry Wall&quot; title=&quot;Larry Wall&quot; /&gt; 
Larry Wall(拉里·沃尔)，1954年9月27日出生在美国加州洛杉矶，是程序员，系统管理者，语言学家和作家，更是一个相当幽默的人。Larry认为好的程序员最重要的三个美德就是“懒惰，急躁，傲慢”。哈哈，也正是或许他真的太符合这个三个特点了，所以导致层级遇到一个棘手的问题，在当年用awk和shell都不能很好的解决，所以开创了Perl创作之路。“洋葱的状态”是 Larry Wall 的年度演讲的主题，洋葱也是 Perl 基金会的标志。&lt;/p&gt;
&lt;h2 id=&quot;perl解释器&quot;&gt;perl解释器&lt;/h2&gt;
&lt;p&gt;Perl是一种解释的脚本语言，相比于Perl的p是小写的perl则是Perl程序的解释器。基于mac系统在命令行直接用命令&lt;/p&gt;
&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;perl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;This&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perl&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subversion&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v5&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;.18.2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;built&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;darwin&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;multi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;level&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;registered&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;patches&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;see&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;V&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;more&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;detail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Copyright&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1987&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2013&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Larry&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Wall&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Perl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;may&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;be&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;copied&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;only&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;under&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;terms&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;either&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Artistic&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;License&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;GNU&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;General&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;License&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;which&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;may&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;be&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;found&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Perl&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Complete&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;documentation&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Perl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;including&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;FAQ&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lists&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;should&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;be&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;found&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;on&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;system&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;man perl&quot;&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;perldoc perl&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;If&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;you&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;have&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;access&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Internet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;your&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;browser&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;at&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;http&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;//&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;perl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;org&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;the&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Perl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Home&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Page&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;从上面的信息来看，当前系统主要搭载的是Perl5系列的5.18版本，通常编写perl脚本语言，都可以采用visual studio或者emacs进行编写，然后通过perl来执行即可&lt;/p&gt;
&lt;h2 id=&quot;perl发展&quot;&gt;Perl发展&lt;/h2&gt;
&lt;p&gt;Larry Wall早已不在亲自编写所有Perl的核心代码，但是他依然会指引开发方向和作为关键的领路人和决策者。当前主要是围绕Perl5的版本进行迭代，但是后来一些人发起了Perl6的开发，想要完全替代Perl5，但是由于进展一度比较慢，而Perl5却是不断的更新从，导致现在Perl5和Perl6的差别比较大，完全是独立的两个方向发展了。Larry Wall已经批准Perl6命名为Raku。&lt;/p&gt;
</description>
        <pubDate>Fri, 18 Oct 2019 20:00:00 +0800</pubDate>
        <link>https://huangxuan.me/2019/10/18/perl%E7%AE%80%E4%BB%8B/</link>
        <guid isPermaLink="true">https://huangxuan.me/2019/10/18/perl%E7%AE%80%E4%BB%8B/</guid>
        
        <category>Perl</category>
        
        <category>programming</category>
        
        
      </item>
    
      <item>
        <title>Hello 2015</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“Yeah It’s on. ”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;Hux 的 Blog 就这么开通了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#build&quot;&gt;跳过废话，直接看技术实现 &lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2015 年，Hux 总算有个地方可以好好写点东西了。&lt;/p&gt;

&lt;p&gt;作为一个程序员， Blog 这种轮子要是挂在大众博客程序上就太没意思了。一是觉得大部分 Blog 服务都太丑，二是觉得不能随便定制不好玩。之前因为太懒没有折腾，结果就一直连个写 Blog 的地儿都没有。&lt;/p&gt;

&lt;p&gt;在玩了一段时间知乎之后，答题的快感又激起了我开博客的冲动。之前的&lt;a href=&quot;http://huangxuan.me/portfolio&quot;&gt;个人网站&lt;/a&gt;是作品集形式的（现在集成进来了），并不适合用来写博文，一不做二不休，花一天搞一个吧！&lt;/p&gt;

&lt;p id=&quot;build&quot;&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;接下来说说搭建这个博客的技术细节。&lt;/p&gt;

&lt;p&gt;正好之前就有关注过 &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt; + &lt;a href=&quot;http://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; 快速 Building Blog 的技术方案，非常轻松时尚。&lt;/p&gt;

&lt;p&gt;其优点非常明显：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Markdown&lt;/strong&gt; 带来的优雅写作体验&lt;/li&gt;
  &lt;li&gt;非常熟悉的 Git workflow ，&lt;strong&gt;Git Commit 即 Blog Post&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;利用 GitHub Pages 的域名和免费无限空间，不用自己折腾主机
    &lt;ul&gt;
      &lt;li&gt;如果需要自定义域名，也只需要简单改改 DNS 加个 CNAME 就好了&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Jekyll 的自定制非常容易，基本就是个模版引擎&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;本来觉得最大的缺点可能是 GitHub 在国内访问起来太慢，所以第二天一起床就到 GitCafe(Chinese GitHub Copy，现在被 Coding 收购了) 迁移了一个&lt;a href=&quot;http://huxpro.coding.me&quot;&gt;镜像&lt;/a&gt;出来，结果还是巨慢。&lt;/p&gt;

&lt;p&gt;哥哥可是个前端好嘛！ 果断开 Chrome DevTool 查了下网络请求，原来是 &lt;strong&gt;pending 在了 Google Fonts&lt;/strong&gt; 上，页面渲染一直被阻塞到请求超时为止，难怪这么慢。&lt;br /&gt;
忍痛割爱，只好把 Web Fonts 去了（反正超时看到的也只能是 fallback ），果然一下就正常了，而且 GitHub 和 GitCafe 对比并没有感受到明显的速度差异，虽然 github 的 ping 值明显要高一些，达到了 300ms，于是用 DNSPOD 优化了一下速度。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;配置的过程中也没遇到什么坑，基本就是 Git 的流程，相当顺手&lt;/p&gt;

&lt;p&gt;大的 Jekyll 主题上直接 fork 了 Clean Blog（这个主题也相当有名，就不多赘述了。唯一的缺点大概就是没有标签支持，于是我给它补上了。）&lt;/p&gt;

&lt;p&gt;本地调试环境需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;gem install jekyll&lt;/code&gt;，结果 rubygem 的源居然被墙了……后来手动改成了我大淘宝的镜像源才成功&lt;/p&gt;

&lt;p&gt;Theme 的 CSS 是基于 Bootstrap 定制的，看得不爽的地方直接在 Less 里改就好了（平时更习惯 SCSS 些），&lt;strong&gt;不过其实我一直觉得 Bootstrap 在移动端的体验做得相当一般，比我在淘宝参与的团队 CSS 框架差多了……&lt;/strong&gt;所以为了体验，也补了不少 CSS 进去&lt;/p&gt;

&lt;p&gt;最后就进入了耗时反而最长的&lt;strong&gt;做图、写字&lt;/strong&gt;阶段，也算是进入了&lt;strong&gt;写博客&lt;/strong&gt;的正轨，因为是类似 Hack Day 的方式去搭这个站的，所以折腾折腾着大半夜就过去了。&lt;/p&gt;

&lt;p&gt;第二天考虑中文字体的渲染，fork 了 &lt;a href=&quot;http://www.typeisbeautiful.com/&quot;&gt;Type is Beautiful&lt;/a&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;font&lt;/code&gt; CSS，调整了字号，适配了 Win 的渣渲染，中英文混排效果好多了。&lt;/p&gt;

&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;回顾这个博客的诞生，纯粹是出于个人兴趣。在知乎相关问题上回答并获得一定的 star 后，我决定把这个博客主题当作一个小小的开源项目来维护。&lt;/p&gt;

&lt;p&gt;在经历 v1.0 - v1.5 的蜕变后，这个博客主题愈发完整，不但增加了诸多 UI 层的优化（opinionated）；在代码层面，更加丰富的配置项也使得这个主题拥有了更好的灵活性与可拓展性。而作为一个开源项目，我也积极的为其完善文档与解决 issue。&lt;/p&gt;

&lt;p&gt;如果你恰好逛到了这里，希望你也能喜欢这个博客主题。&lt;/p&gt;

&lt;p&gt;—— Hux 后记于 2015.10&lt;/p&gt;

</description>
        <pubDate>Thu, 29 Jan 2015 20:00:00 +0800</pubDate>
        <link>https://huangxuan.me/2015/01/29/hello-2015/</link>
        <guid isPermaLink="true">https://huangxuan.me/2015/01/29/hello-2015/</guid>
        
        <category>生活</category>
        
        <category>Meta</category>
        
        
      </item>
    
  </channel>
</rss>
